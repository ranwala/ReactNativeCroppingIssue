import {
  MedicalCertificateCheckboxField,
  MedicalCertificateDateField,
  MedicalCertificateFormType,
  AUSCheckResult,
  CheckStandard,
  FRACheckResult,
  INDCheckResult,
  KWTCheckResult,
  Status,
  USACheckResult,
  UnknownCheckResult,
  DetectionStatus,
  Point,
  Page,
  MRZDocumentType,
  BarcodeFormat,
  GenericDocumentType,
  CheckStatus,
  AAMVADocumentFormat,
  BoardingPassDocumentFormat,
  GS1DocumentFormat,
  IDCardPDF417DocumentFormat,
  MedicalCertificateDocumentFormat,
  MedicalPlanDocumentFormat,
  SEPADocumentFormat,
  SwissQRCodeDocumentFormat,
  VCardDocumentFormat,
  LicenseStatus,
  MRZRecognizerResultField,
  DetectBarcodesOnImagesField,
  PolygonPoint,
} from './types';

export interface DocumentDetectionResult {
  detectionResult: DetectionStatus;
  polygon?: Point[];
  documentImageFileUri?: string;
}

export interface DocumentScannerResult {
  status: Status;
  pages: Page[];
}

export interface CroppingResult {
  status: Status;
  page?: Page;
}

export interface MrzRecognitionResult {
  recognitionSuccessful: boolean;
  documentType: MRZDocumentType;
  checkDigitsCount: number;
  validCheckDigitsCount: number;
  fields: {
    name: string;
    value: string;
    confidence: number;
  }[];
}

export interface HealthInsuranceCardScannerResult {
  status: Status;
  fields: {
    type: string;
    value: string;
    confidence: number;
  }[];
}

export interface TextDataScannerResult {
  status: Status;
  result?: {
    text: string;
    confidence: number;
  };
}

export interface MedicalCertificateScannerResult {
  /**
   * `'OK'` if the Medical Certificate was scanned, `'CANCELED'` if the user canceled the scanner UI.
   */
  status: Status;
  /**
   * The Medical Certificate Form Type
   */
  formType: MedicalCertificateFormType;
  /**
   * Image file uri of the captured Medical Certificate
   */
  imageFileUri?: string;
  /**
   * The extracted patient data
   */
  patientData: {
    /**
     * The health insurance provider.
     */
    insuranceProvider?: string;
    /**
     * The patients first name.
     */
    firstName?: string;
    /**
     * The patients last name.
     */
    lastName?: string;
    /**
     * The patients address 1.
     */
    address1?: string;
    /**
     * The patients address 2.
     */
    address2?: string;
    /**
     * The patients diagnose.
     */
    diagnose?: string;
    /**
     * The patients health insurance number.
     */
    healthInsuranceNumber?: string;
    /**
     * The patients person number.
     */
    insuredPersonNumber?: string;
    /**
     * The patients status.
     */
    status?: string;
    /**
     * The place of operation number.
     */
    placeOfOperationNumber?: string;
    /**
     * The doctors number.
     */
    doctorNumber?: string;
    /**
     * An undefined field, that was recognized still.
     */
    unknown?: string;
  };
  /**
   * The extracted dates data
   */
  dates: {
    /**
     * The date since when the employee is incapable of work.
     */
    incapableOfWorkSince?: MedicalCertificateDateField;
    /**
     * The date until when the employee is incapable of work.
     */
    incapableOfWorkUntil?: MedicalCertificateDateField;
    /**
     * The date of the day of diagnosis.
     */
    diagnosedOn?: MedicalCertificateDateField;
    /**
     * The date since when the child needs care.
     */
    childNeedsCareFrom?: MedicalCertificateDateField;
    /**
     * The date until the childs needs care.
     */
    childNeedsCareUntil?: MedicalCertificateDateField;
    /**
     * Patient birth date.
     */
    birthDate?: MedicalCertificateDateField;
    /**
     * Document date.
     */
    documentDate?: MedicalCertificateDateField;
    /**
     * An unclassified date, which was recognized still
     */
    unknown?: MedicalCertificateDateField;
  };
  /**
   * The extracted checkboxes data.
   * It contains information about the medical form checkboxes type
   * and whether they are checked or not.
   */
  checkboxes: {
    /**
     * The checkbox states if the certificate is an initial certificate.
     */
    initialCertificate?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is a renewed certificate.
     */
    renewedCertificate?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is about a work accident.
     */
    workAccident?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is assigned to an accident insurance doctor.
     */
    assignedToAccidentInsuranceDoctor?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is about an accident checked yes.
     */
    accident?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is about an accident checked no.
     */
    accidentNo?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if ill child requires care checked yes.
     */
    requiresCare?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if ill child requires care checked no.
     */
    requiresCareNo?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the insurance company has to pay for treatment.
     */
    insuredPayCase?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is final.
     */
    finalCertificate?: MedicalCertificateCheckboxField;
    /**
     * The checkbox states if the certificate is assigned to an other accident
     */
    otherAccident?: MedicalCertificateCheckboxField;
    /**
     * The checkbox could not be classified, but it was recognized still
     */
    unknown?: MedicalCertificateCheckboxField;
  };
}

export interface LicensePlateScannerResult {
  /**
   * `'OK'` if the License Plate was scanned, `'CANCELED'` if the user canceled the scanner UI.
   */
  status: Status;
  /**
   * The License Plate detected by the scanner
   */
  licensePlate?: string;
  /**
   * Confidence in the accuracy of the detection (0 - 100)
   */
  confidence?: number;
  /**
   * The Country Code on the License Plate as detected by the scanner
   */
  countryCode?: string;
  /**
   * The entire raw text detected on the License Plate by the scanner
   */
  rawText?: string;
  /**
   * 'true' if the validation of the scanned license plate was successful, 'false' otherwise - iOS only.
   */
  isValidationSuccessful?: boolean;
}

export interface MrzResult extends MrzRecognitionResult {
  status: Status;
}

export interface BarcodeResult {
  status: Status;
  barcodes?: BarcodeResultField[];
}

export interface GenericDocumentField {
  text?: string;
  confidence?: number;
}

export interface DriverLicenseCategory {
  restrictions?: GenericDocumentField;
  validFrom?: GenericDocumentField;
  validUntil?: GenericDocumentField;
}

export interface DriverLicenseCategories {
  a?: DriverLicenseCategory;
  a1?: DriverLicenseCategory;
  a2?: DriverLicenseCategory;
  b?: DriverLicenseCategory;
  b1?: DriverLicenseCategory;
  be?: DriverLicenseCategory;
  c?: DriverLicenseCategory;
  c1?: DriverLicenseCategory;
  c1e?: DriverLicenseCategory;
  ce?: DriverLicenseCategory;
  d?: DriverLicenseCategory;
  d1?: DriverLicenseCategory;
  d1e?: DriverLicenseCategory;
  de?: DriverLicenseCategory;
  l?: DriverLicenseCategory;
  m?: DriverLicenseCategory;
  t?: DriverLicenseCategory;
}

export interface DeDriverLicenseResult {
  birthDate?: GenericDocumentField;
  birthplace?: GenericDocumentField;
  expiryDate?: GenericDocumentField;
  givenNames?: GenericDocumentField;
  id?: GenericDocumentField;
  issueDate?: GenericDocumentField;
  issuingAuthority?: GenericDocumentField;
  licenseCategories?: GenericDocumentField;
  photoImageUri?: string;
  signatureImageUri?: string;
  surname?: GenericDocumentField;
  restrictions?: GenericDocumentField;
  categories?: DriverLicenseCategories;
}

export interface DePassportResult {
  birthDate?: GenericDocumentField;
  birthplace?: GenericDocumentField;
  countryCode?: GenericDocumentField;
  expiryDate?: GenericDocumentField;
  gender?: GenericDocumentField;
  givenNames?: GenericDocumentField;
  id?: GenericDocumentField;
  issueDate?: GenericDocumentField;
  issuingAuthority?: GenericDocumentField;
  maidenName?: GenericDocumentField;
  nationality?: GenericDocumentField;
  passportType?: GenericDocumentField;
  photoImageUri?: string;
  rawMrz?: GenericDocumentField;
  signatureImageUri?: string;
  surname?: GenericDocumentField;
  mrz?: MrzDocumentResult;
}

export interface MrzDocumentResult {
  birthDate?: GenericDocumentField;
  checkDigits?: GenericDocumentField[];
  documentNumber?: GenericDocumentField;
  expiryDate?: GenericDocumentField;
  gender?: GenericDocumentField;
  givenNames?: GenericDocumentField;
  issuingAuthority?: GenericDocumentField;
  nationality?: GenericDocumentField;
  optional1?: GenericDocumentField;
  optional2?: GenericDocumentField;
  surname?: GenericDocumentField;
  travelDocType?: GenericDocumentField;
  travelDocTypeVariant?: GenericDocumentField;
}

export interface DeIdCardResult {
  birthDate?: GenericDocumentField;
  birthplace?: GenericDocumentField;
  expiryDate?: GenericDocumentField;
  givenNames?: GenericDocumentField;
  id?: GenericDocumentField;
  maidenName?: GenericDocumentField;
  nationality?: GenericDocumentField;
  pin?: GenericDocumentField;
  photoImageUri?: string;
  signatureImageUri?: string;
  surname?: GenericDocumentField;
  address?: GenericDocumentField;
  eyeColor?: GenericDocumentField;
  height?: GenericDocumentField;
  issueDate?: GenericDocumentField;
  issuingAuthority?: GenericDocumentField;
  pseudonym?: GenericDocumentField;
  rawMrz?: GenericDocumentField;
}

export type GenericDocumentFields =
  | DeDriverLicenseResult
  | DePassportResult
  | DeIdCardResult;

export interface GenericDocumentRecognizerResult {
  documentType: GenericDocumentType;
  status: Status;
  fields: GenericDocumentFields;
}
/* --------------------------------------------------------------- */
/* --------------------------------------------------------------- */

export interface ApplyImageFilterResult {
  /** The URI of the filtered image */
  imageFileUri: string;
}

export interface BarcodeResultField {
  /** The recognized barcode type */
  type: BarcodeFormat;
  /** The recognized barcode text */
  text: string;
  /** The recognized barcode text with extension (if available) */
  textWithExtension: string;
  /** The array of raw bytes that compose the recognized barcode */
  rawBytes: number[];
  /** True if the Barcode Document has been parsed successfully */
  parsedSuccessful: boolean;
  /** The formatted barcode document (if it was parsed succesfully) */
  formattedResult?:
    | AAMVADocumentFormat
    | BoardingPassDocumentFormat
    | GS1DocumentFormat
    | IDCardPDF417DocumentFormat
    | MedicalCertificateDocumentFormat
    | MedicalPlanDocumentFormat
    | SEPADocumentFormat
    | SwissQRCodeDocumentFormat
    | VCardDocumentFormat;
}

export interface CheckRecognizerResult {
  /** Check Recognizer recognized fields */
  fields:
    | USACheckResult
    | FRACheckResult
    | KWTCheckResult
    | AUSCheckResult
    | INDCheckResult
    | UnknownCheckResult;
  /** The status of the operation */
  checkStatus: CheckStatus;
  /** The URI of the snapped Check Image */
  imageFileUri?: string;
  /** The type of the recognized check */
  checkType: CheckStandard;
}

export interface CreatePDFResult {
  /** The URI of the generated PDF file */
  pdfFileUri: string;
}

export interface DetectBarcodesOnImageResult {
  /** The detected barcodes */
  barcodes: BarcodeResultField[];
}

export interface DetectBarcodesOnImagesResult {
  /** An array for which each element has a imageUri and the list of detected barcodes */
  results: DetectBarcodesOnImagesField[];
}

export interface DetectDocumentResult {
  /** The URI of the document image file, if something is detected */
  documentImageFileUri?: string;
  /** The array of detected polygon points, if something is detected */
  polygon?: PolygonPoint[];
  /** The status of the detection */
  detectionResult: DetectionStatus;
}

export interface EstimateBlurResult {
  /** Estimated blur level */
  blur: number;
}

export interface ExtractImagesFromPdfResult {
  /** The URIs of the extracted images */
  imageFilesUrls: string[];
}

export interface ExtractPagesFromPdfResult {
  /** The extracted pages */
  pages: Page[];
}

export interface GetFilteredDocumentPreviewUriResult {
  /** The URI of the filtered document preview image */
  filteredDocumentPreviewUri: string;
}

export interface GetImageDataResult {
  /** The Base 64 encoded representation of the image data */
  base64ImageData: string;
}

export interface GetLicenseInfoResult {
  /** True if the license is valid, false otherwise */
  isLicenseValid: boolean;
  /** The license status */
  licenseStatus: LicenseStatus;
  /** The license expiration date in milliseconds */
  licenseExpirationDate: number;
}

export interface GetOCRConfigsResult {
  /** The OCR languages data path */
  languageDataPath: string;
  /** The installed OCR languages */
  installedLanguages: string[];
}

export interface InitializeSDKResult {
  /** The result initialization message */
  result: string;
}

export interface PerformOCRResult {
  /** The OCR result as plain text */
  plainText?: string;
  /** The URI of the PDF file */
  pdfFileUri?: string;
  /** The OCR result as JSON data */
  jsonData?: any;
}

export interface RecognizeMRZResult {
  /** True if the recognition was successful, false otherwise */
  recognitionSuccessful: boolean;
  /** The recognized document type */
  documentType: MRZDocumentType;
  /** Total number of check digits as required by the travel document type */
  checkDigitsCount: number;
  /** Number of successfully validated check digits. */
  validCheckDigitsCount: number;
  /** The raw string of the recognized machine readable zone. */
  rawString: string;
  /** An array of all recognized fields */
  fields: MRZRecognizerResultField[];
}

export interface RefreshImageUrisResult {
  /** The refreshed pages */
  pages: Page[];
}

export interface RemovePageResult {
  /** Operation Result */
  operationResult: string;
}

export interface RotateImageResult {
  /** The URI of the rotated image */
  imageFileUri: string;
}

export interface WriteTIFFResult {
  /** The URI of the output TIFF file */
  tiffFileUri: string;
}
