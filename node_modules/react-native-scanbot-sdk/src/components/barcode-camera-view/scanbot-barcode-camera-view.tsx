import React from 'react';
import {EmitterSubscription, Platform} from 'react-native';
import {Dimensions} from 'react-native';
import {ScanbotBarcodeCameraViewProperties} from './scanbot-barcode-camera-view-types';
import ScanbotNativeBarcodeCameraView from './scanbot-native-barcode-camera-view';

const Device = {
  isPortrait: () => {
    const dim = Dimensions.get('screen');
    return dim.height >= dim.width;
  },
  isLandscape: () => {
    const dim = Dimensions.get('screen');
    return dim.width >= dim.height;
  },
};

interface ScanbotBarcodeCameraViewState {
  orientation: string;
}

type Properties = ScanbotBarcodeCameraViewProperties;
export class ScanbotBarcodeCameraView extends React.Component<Properties, {}> {
  // String length of auto-generated component key
  static UNIQUE_VIEW_KEY_LENGTH = 6;

  // Listener for orientation changes
  dimensionsChangeSubscription: EmitterSubscription | null = null;

  // This attribute allows us to retrieve a key for the component depending on the current state.
  // If the component has been invalidated, it returns a new key and the view gets recreated,
  // otherwise it uses the last generated one
  _cameraKey = '';
  get cameraKey(): string {
    if (!this.isDirty) {
      return this._cameraKey;
    }
    this.isDirty = false;
    this._cameraKey = ScanbotBarcodeCameraView.getRandomId(
      ScanbotBarcodeCameraView.UNIQUE_VIEW_KEY_LENGTH,
    );
    return this._cameraKey;
  }

  // We keep track of the state of children components, so that we can re-render the component
  // in some special cases (Android)
  previousChildrenIds: string[] = [];
  get childrenIds(): string[] {
    const children = this.props.children
      ? React.Children.map(this.props.children, child => child)
      : [];

    return children?.map((c: any) => `${c.type.name}-${c.key}`) ?? [];
  }

  // When true, a new component key will be generated on the next render,
  // causing the component to be recreated
  isDirty = true;

  state: ScanbotBarcodeCameraViewState = {
    orientation: Device.isPortrait() ? 'portrait' : 'landscape',
  };

  // Returns a random string ID of the given length
  static getRandomId(
    length: number = ScanbotBarcodeCameraView.UNIQUE_VIEW_KEY_LENGTH,
  ): string {
    let result = '';
    const characters =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }

  // Event Listener for orientation changes
  orientationChangeHandler = () => {
    this.isDirty = true;
    this.setState({
      orientation: Device.isPortrait() ? 'portrait' : 'landscape',
    });
  };

  // Maps the native bridge callback event from the Barcode Scanner
  _onBarcodeScannerResult = (event: any) => {
    if (!this.props.onBarcodeScannerResult) {
      return;
    }

    this.props.onBarcodeScannerResult(event.nativeEvent.result);
  };

  render() {
    this.evaluateComponentState();

    const style = this.preprocessStyle();
    const props = this.preprocessProps();

    return (
      <ScanbotNativeBarcodeCameraView
        {...props}
        style={style}
        key={this.cameraKey}
        requestComponentReload={this._invalidate}
        onBarcodeScannerResult={this._onBarcodeScannerResult}
      />
    );
  }

  componentDidMount() {
    this.registerDimensionsListener();
    this.previousChildrenIds = this.childrenIds;
  }

  componentWillUnmount() {
    this.unregisterDimensionsListener();
    this.previousChildrenIds = [];
  }

  evaluateComponentState = () => {
    // We want to force a re-layout every time new children are added or removed
    // from the BarcodeCameraView on Android; this will allow the native code to
    // re-compute the size of every view inside the layout
    if (Platform.OS === 'android') {
      const currentChildrenIds = this.childrenIds;

      const invalidate = () => {
        this._invalidate();
        this.previousChildrenIds = currentChildrenIds;
      };
      if (currentChildrenIds.length !== this.previousChildrenIds.length) {
        invalidate();
        return;
      }

      for (let i = 0; i < this.previousChildrenIds.length; i++) {
        const previous = this.previousChildrenIds[i];
        const current = currentChildrenIds[i];
        if (previous !== current) {
          invalidate();
          return;
        }
      }
    }
  };

  preprocessStyle = () => {
    const style = this.props.style as any;
    const newStyle = {...style} || {};
    // Override / Define styles here
    return newStyle;
  };

  preprocessProps = () => {
    const props = {...this.props};
    delete props.style;
    return props;
  };

  // Invalidates the component so that it gets recreated on the next render
  _invalidate = () => {
    this.isDirty = true;
  };

  registerDimensionsListener() {
    if (this.usesEmitterSubscription()) {
      this.dimensionsChangeSubscription = Dimensions.addEventListener(
        'change',
        this.orientationChangeHandler,
      ) as unknown as EmitterSubscription;
    } else {
      Dimensions.addEventListener('change', this.orientationChangeHandler);
    }
  }

  unregisterDimensionsListener() {
    if (this.usesEmitterSubscription()) {
      if (this.dimensionsChangeSubscription) {
        this.dimensionsChangeSubscription.remove();
      }
    } else {
      (Dimensions as any).removeEventListener(
        'change',
        this.orientationChangeHandler,
      );
    }
  }

  // Since React Native 0.70 the method removeEventListener has been removed in favour of EmitterSubscription (returned by addEventListener)
  // .remove() method; here we check if removeEventListener still exists in Dimensions to check if React Native < 0.70 is used
  usesEmitterSubscription(): boolean {
    return (
      (Dimensions as any).removeEventListener == null ||
      (Dimensions as any).removeEventListener === undefined
    );
  }
}
